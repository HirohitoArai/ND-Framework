// This file was originally generated by the bivector.net tool,
// created by Steven De Keninck (enki).
// The original code is provided under a permissive license (assumed to be MIT or similar)
// allowing for modification and redistribution.
//
// Significant performance optimizations (Fluent Interface, ThreadStatic buffer)
// have been applied by Hirohito Arai.

// Written by a generator written by enki.
using System;
using UnityEngine;

namespace GeometricAlgebra3D
{
	[System.Serializable]
	public struct Bivector3D
	{
		public float xy, xz, yz;
		public Bivector3D(float xy = 0, float xz = 0, float yz = 0)
		{ this.xy = xy; this.xz = xz; this.yz = yz; }
		public static Bivector3D zero => new Bivector3D(0f, 0f, 0f);
		public static Bivector3D Rotxy => new Bivector3D(1f, 0f, 0f);
		public static Bivector3D Rotxz => new Bivector3D(0f, 1f, 0f);
		public static Bivector3D Rotyz => new Bivector3D(0f, 0f, 1f);
		public float NormSq() => xy * xy + xz * xz + yz * yz;
		public Bivector3D Normalized()
		{
			float nSq = NormSq();
			if (nSq > 1e-12f) {
				float n = Mathf.Sqrt(nSq);
				return new Bivector3D(xy / n, xz / n, yz / n);
			}
			return new Bivector3D();
		}
		public static float Dot(Bivector3D a, Bivector3D b) => a.xy * b.xy + a.xz * b.xz + a.yz * b.yz;

		public override string ToString()
		{
			return $"({xy}, {xz}, {yz})";
		}
	}
	public class GA3D
	{
		public static float EPS = 1e-6f;
		[ThreadStatic]
		private static float[] _tempCalculationBuffer;
		private float[] _mVec = new float[8];

		public GA3D(float f = 0f, int idx = 0)
		{
			_mVec[idx] = f;
		}

		public float this[int idx]
		{
			get { return _mVec[idx]; }
			set { _mVec[idx] = value; }
		}
		public GA3D Set(GA3D other)
		{
			Array.Copy(other._mVec, this._mVec, 8);
			return this;
		}
		public GA3D Zero()
		{
			Array.Clear(this._mVec, 0, 8);
			return this;
		}
		// Vector3‚ðGA3D‚É•ÏŠ·
		public GA3D ConvertVectorToGA3D(Vector3 v)
		{
			this.Zero();
			this._mVec[1] = v.x;
			this._mVec[2] = v.y;
			this._mVec[3] = v.z;
			return this;
		}
		public GA3D Reverse()
		{
			this[4] = -this[4];
			this[5] = -this[5];
			this[6] = -this[6];
			this[7] = -this[7];
			return this;
		}
		public GA3D Dual()
		{
			if (_tempCalculationBuffer == null)
			{
				_tempCalculationBuffer = new float[7];
			}
			var temp = _tempCalculationBuffer;
			Array.Copy(this._mVec, temp, 7);
			this._mVec[0] = temp[7];
			this._mVec[1] = temp[6];
			this._mVec[2] = -temp[5];
			this._mVec[3] = temp[4];
			this._mVec[4] = -temp[3];
			this._mVec[5] = -temp[2];
			this._mVec[6] = temp[1];
			this._mVec[7] = -temp[0];

			return this;
		}
		public GA3D Conjugate()
		{
			this[1] = -this[1];
			this[2] = -this[2];
			this[3] = -this[3];
			this[4] = -this[4];
			this[5] = -this[5];
			this[6] = -this[6];

			return this;
		}

		public GA3D Multiply(GA3D other)
		{
			if (_tempCalculationBuffer == null)
			{
				_tempCalculationBuffer = new float[8];
			}
			var tempResult = _tempCalculationBuffer;

			tempResult[0] = other[0] * this[0] + other[1] * this[1] + other[2] * this[2] + other[3] * this[3] - other[4] * this[4] - other[5] * this[5] - other[6] * this[6] - other[7] * this[7];
			tempResult[1] = other[1] * this[0] + other[0] * this[1] - other[4] * this[2] - other[5] * this[3] + other[2] * this[4] + other[3] * this[5] - other[7] * this[6] - other[6] * this[7];
			tempResult[2] = other[2] * this[0] + other[4] * this[1] + other[0] * this[2] - other[6] * this[3] - other[1] * this[4] + other[7] * this[5] + other[3] * this[6] + other[5] * this[7];
			tempResult[3] = other[3] * this[0] + other[5] * this[1] + other[6] * this[2] + other[0] * this[3] - other[7] * this[4] - other[1] * this[5] - other[2] * this[6] - other[4] * this[7];
			tempResult[4] = other[4] * this[0] + other[2] * this[1] - other[1] * this[2] + other[7] * this[3] + other[0] * this[4] - other[6] * this[5] + other[5] * this[6] + other[3] * this[7];
			tempResult[5] = other[5] * this[0] + other[3] * this[1] - other[7] * this[2] - other[1] * this[3] + other[6] * this[4] + other[0] * this[5] - other[4] * this[6] - other[2] * this[7];
			tempResult[6] = other[6] * this[0] + other[7] * this[1] + other[3] * this[2] - other[2] * this[3] - other[5] * this[4] + other[4] * this[5] + other[0] * this[6] + other[1] * this[7];
			tempResult[7] = other[7] * this[0] + other[6] * this[1] - other[5] * this[2] + other[4] * this[3] + other[3] * this[4] - other[2] * this[5] + other[1] * this[6] + other[0] * this[7];
			Array.Copy(tempResult, this._mVec, 8);
			return this;
		}
		public GA3D Wedge(GA3D other)
		{
			if (_tempCalculationBuffer == null)
			{
				_tempCalculationBuffer = new float[8];
			}
			var tempResult = _tempCalculationBuffer;
			tempResult[0] = other[0] * this[0];
			tempResult[1] = other[1] * this[0] + other[0] * this[1];
			tempResult[2] = other[2] * this[0] + other[0] * this[2];
			tempResult[3] = other[3] * this[0] + other[0] * this[3];
			tempResult[4] = other[4] * this[0] + other[2] * this[1] - other[1] * this[2] + other[0] * this[4];
			tempResult[5] = other[5] * this[0] + other[3] * this[1] - other[1] * this[3] + other[0] * this[5];
			tempResult[6] = other[6] * this[0] + other[3] * this[2] - other[2] * this[3] + other[0] * this[6];
			tempResult[7] = other[7] * this[0] + other[6] * this[1] - other[5] * this[2] + other[4] * this[3] + other[3] * this[4] - other[2] * this[5] + other[1] * this[6] + other[0] * this[7];
			Array.Copy(tempResult, this._mVec, 8);
			return this;
		}

		//Scalar division
		public GA3D Divide(float scalar)
		{
			if (Mathf.Abs(scalar) < 1e-12f) return this;
			float inv_scalar = 1.0f / scalar;
			for (int i = 0; i < 8; i++) this[i] *= inv_scalar;
			return this;
		}

		private static GA3D _temp_self = new();
		private static GA3D _temp_conjugate = new();
		private static GA3D _temp_blade = new();

		private static GA3D _ga_v0 = new();
		private static GA3D _ga_v1 = new();
		private static GA3D _ga_rotor = new();

		public float Norm()
		{
			_temp_conjugate.Set(this).Conjugate();
			_temp_self.Set(this).Multiply(_temp_conjugate);
			return Mathf.Sqrt(Mathf.Abs(_temp_self[0]));
		}
		
		//Generate a rotor from two vectors
		public GA3D CreateRotorWithVector(Vector3 v0, Vector3 v1,float angleDeg)
		{
			_ga_v0.ConvertVectorToGA3D(v0);
			_ga_v1.ConvertVectorToGA3D(v1);
			_temp_self.Set(_ga_v0).Wedge(_ga_v1);

			_temp_blade.Zero();
			_temp_blade[4] = _temp_self[4];
			_temp_blade[5] = _temp_self[5];
			_temp_blade[6] = _temp_self[6];

			float norm = _temp_blade.Norm();
			if (norm > EPS)
			{
				_temp_blade.Divide(norm);
			}
			float halfAngleRad = (angleDeg % 360) * Mathf.Deg2Rad * -0.5f;
			float c = Mathf.Cos(halfAngleRad);
			float s = Mathf.Sin(halfAngleRad);
    
			this[0] = c;
			this[4] = s * _temp_blade[4];
			this[5] = s * _temp_blade[5];
			this[6] = s * _temp_blade[6];
			return this;
		}

		//Generate rotors from bivectors and Euler angles
		public GA3D CreateRotor(Bivector3D blade, float angleDeg)
		{
			if (blade.NormSq() < EPS)
			{
				this.Zero(); 
				this[0] = 1f;
				return this;
			}
    
			float halfAngleRad = (angleDeg % 360) * Mathf.Deg2Rad * -0.5f;
			float c = Mathf.Cos(halfAngleRad);
			float s = Mathf.Sin(halfAngleRad);
			Bivector3D b_norm = blade.Normalized();
    
			this.Zero();
			this[0] = c;
			this[4] = s * b_norm.xy;
			this[5] = s * b_norm.xz;
			this[6] = s * b_norm.yz;
			return this;
		}

		//Rotor spinning vector
		public static void RotateVector(in Vector3 v0, GA3D rotor, out Vector3 result)
		{
			_ga_v0.ConvertVectorToGA3D(v0);
			_ga_rotor.Set(rotor).Reverse();
			_ga_v1.Set(rotor).Multiply(_ga_v0).Multiply(_ga_rotor);

			result.x = _ga_v1[1];
			result.y = _ga_v1[2];
			result.z = _ga_v1[3];
		}
	}
}
